## 15. 複数のステージを用意してみよう

### 概要

前章ではボスをつくることができました。この章ではステージを作っていきたいと思います。

### ステージを管理するクラスを作る

その名も ```StageManager``` そのままですが、パターンを決めて敵を出現させるためには、それを管理するクラスが必要です。

では、 ```StageManager.cs``` を作り、以下のように編集しましょう。

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace STG
{
    public class StageManager
    {
        // 一度だけインスタンス化される
        public static StageManager Instance = new StageManager();

    	// シングルトンパターンに従う
        static StageManager() { }
    }
}
```

```StageManager``` クラスをインスタンス化するのは1度で十分です。この時、静的なインスタンスを1つ生成しておくと、どこからでも ```StageManager``` を利用できるようになります。このとき生成するインスタンスはクラス変数に格納しておきます。

### StageManagerが持つフィールドを考える

まず、敵を出現させるために、その出現場所になる ```gameLayer``` 、敵のコンストラクタに必要な ```player``` 、倒すとステージを進める ```boss``` 、ステージ数を管理する ```stage```、 経過フレームを計測する ```count```、 敵を予めセットしておく ```enemyQueues``` を宣言しておきます。

ここでは、新しく[キュー](https://msdn.microsoft.com/ja-jp/library/7977ey2c%28v=vs.110%29.aspx)を使用します。このキューは店の前に並ぶ行列をイメージしてくれると理解が早いと思います。

行列の先端の人が店に入るのがデキュー(dequeue)、行列の最後尾に人が並ぶのがエンキュー(enqueue)、行列そのものをキュー(queue)と読み替えるといいでしょう。こ

今回は、敵をステージに送り出す行列として、キューを使用します。そのキューをステージごとに用意するというわけです。

ステージを3つ用意するということで、以下のように ```StageManager.cs``` を編集します。

```diff
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace STG
{
    public class StageManager
    {
        // 一度だけインスタンス化される
        public static StageManager Instance = new StageManager();

+        // 敵の出現するレイヤーを持つ
+        GameLayer gameLayer;

+        // プレイヤーの参照を持つ
+        Player player;
        
+        // ステージの最後にボスが出る
+        Boss boss;

+        // ステージ数を管理
+        int stage;

+        // ゲームの経過時間を管理
+        int count;

+        // ステージごとに敵を入れておくキュー
+        Queue<Enemy>[] enemyQueues = new Queue<Enemy>[3];

        // シングルトンパターンに従う
        static StageManager() { }
    }
}
```

### StageManagerを初期化する

```player``` や ```gameLayer``` をインスタンス化してから ```StageManager``` のインスタンスを初期化することを考えます。そのために ```init``` メソッドを用意します。

この ```init``` メソッドでは、宣言した変数について、中身を代入することについて考えます。（```boss``` については後述）

このとき、 ```initStage[番号]``` メソッドを用意して、敵をキューにエンキューしておくことを考えます。（エンキューしておいた敵は、該当するステージに出現するように、後ほど処理を書きます。）

```diff
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace STG
{
    public class StageManager
    {

        ...(省略)...

        // シングルトンパターンに従う
        static StageManager() { }

+        public void init(GameLayer gameLayer, Player player)
+        {
+            // 敵を出現させるレイヤーを設定する
+            this.gameLayer = gameLayer;

+            // プレイヤーの参照を設定する
+            this.player = player;

+            // 最初のステージを0とする
+            stage = 0;

+            // ゲーム内のカウントを0にする
+            count = 0;
            
+            // ステージ0用の敵をセットする
+            initStage0();

+            // ステージ1用の敵をセットする
+            initStage1();

+            // ステージ2用の敵をセットする
+            initStage2();
+        }

+        private void initStage0()
+        {
+            enemyQueues[0] = new Queue<Enemy>();
+            // ステージ0のキューに敵をエンキューしていく
+        }

+        private void initStage1()
+        {
+            enemyQueues[1] = new Queue<Enemy>();
+            // ステージ1のキューに敵をエンキューしていく
+        }

+        private void initStage2()
+        {
+            enemyQueues[2] = new Queue<Enemy>();
+            // ステージ2のキューに敵をエンキューしていく
+        }
    }
}
```

### 敵をエンキューしておく

ステージ0を例に挙げましょう。以下のように ```initStage0``` メソッドを編集してみました。基本的には、キューに敵をエンキューしていくだけです。

```cs
        private void initStage0()
        {
            // enemyQueue[0]にQueue<Enemy>をインスタンス化する。このキューにステージ0の敵を入れておく。
            enemyQueues[0] = new Queue<Enemy>();

            // 敵を射出する速度 moveVelocity を設定しておく
            ace.Vector2DF moveVelocity = new ace.Vector2DF(2.0f, 0.0f);

            // 10回ループする
            for (int i = 0; i < 10; i++)
            {
                // 速度を60度の向きに
                moveVelocity.Degree = 60;

                // 左側に敵を出現させる
                enemyQueues[0].Enqueue(new StraightMovingEnemy(new ace.Vector2DF(100.0f, 0.0f), moveVelocity, player));
                
                // 速度を120度の向きに
                moveVelocity.Degree = 120;

                // 右側に敵を出現させる
                enemyQueues[0].Enqueue(new StraightMovingEnemy(new ace.Vector2DF(540.0f, 0.0f), moveVelocity, player));
            }

            // 20回ループする
            for (int i = 0; i < 20; i++)
            {
                // 速度を90度の向きに
                moveVelocity.Degree = 90;

                // 左側に敵を出現させる
                enemyQueues[0].Enqueue(new StraightMovingEnemy(new ace.Vector2DF(100.0f, 0.0f), moveVelocity, player));
            }

            // 20回ループする
            for (int i = 0; i < 20; i++)
            {
                // 速度を90度の向きに
                moveVelocity.Degree = 90;

                // 右側に敵を出現させる
                enemyQueues[0].Enqueue(new StraightMovingEnemy(new ace.Vector2DF(540.0f, 0.0f), moveVelocity, player));
            }
        }
```

これでステージ0のキューには、一定の敵出現パターンが記憶されました。

これをデキューしてステージに出現させる必要があります。

## 敵をステージに出現させる

敵をステージに出現させるために ```StageManager``` に ```onUpdate``` メソッドを作り、その中に更新処理を書きましょう。

```cs
        // 自分で作ったonUpdateなので、メインループで呼ぶ必要がある
        public void onUpdate()
        {
            // ステージに対応するキューが空でないならば
            if (enemyQueues[stage].Count > 0)
            {
                // countが72の倍数の時に
                if (count % 72 == 0)
                {
                    // 敵を出現させる
                    gameLayer.AddObject(enemyQueues[stage].Dequeue());
                }
            }

            // そのステージの敵が出現し終わったら
            else
            {
                // ボスが出現してないときに
                if (boss == null)
                {
                    // ボスを出現させる
                    boss = new Boss(new ace.Vector2DF(320.0f, 0.0f), player);

                    // ボスをレイヤーに追加する
                    gameLayer.AddObject(boss);
                }

                else
                {
                    // ボスが倒れたとき
                    if (!boss.IsAlive)
                    {
                        // ステージが2未満の時
                        if (stage < 2)
                        {
                            // ボスを初期化しておいて
                            boss = null;

                            // ステージを先に進める
                            ++stage;
                        }
                    }
                }
            }
            // onUpdate ごとに count を進める
            ++count;
        }
```
上から順に見ていきましょう。

```cs
                // countが72の倍数の時に
                if (count % 72 == 0)
                {
                    // 敵を出現させる
                    gameLayer.AddObject(enemyQueues[stage].Dequeue());
                }
```
まず、敵がまだ現れる、すなわちキューが空でない場合について考えましょう。この時はキューの中身をデキューし、敵を出現させることが可能です。

毎フレーム敵が出現するとすぐにキューの中身が空っぽになってしまうので、フレーム(count)がある倍数のときだけデキューする。というように敵を出現させるといい感じになります。

このとき、デキューした敵を直接レイヤーに入れることができます。

では次に、敵が全てで終わった場合です。この時にボスを出したいと思います。

以下のコードはキューが空になった場合の挙動です。

```cs
                // ボスが出現してないときに
                if (boss == null)
                {
                    // ボスを出現させる
                    boss = new Boss(new ace.Vector2DF(320.0f, 0.0f), player);

                    // ボスをレイヤーに追加する
                    gameLayer.AddObject(boss);
                }

                else
                {
                    // ボスが倒れたとき
                    if (!boss.IsAlive)
                    {
                        // ステージが2未満の時
                        if (stage < 2)
                        {
                            // ボスを初期化しておいて
                            boss = null;

                            // ステージを先に進める
                            ++stage;
                        }
                    }
                }
```

ボスがそのステージでまだ出現していないという状態を ```boss == null``` とします。

また、ボスが倒された状態は ```!boss.IsAlive``` ボスが生きて「いない」(!で否定を表します)すなわち、ボスが倒された状態として表されます。

キューが空になった場合には、まず ```boss``` が出現したかどうかを考えます。出現していない場合には ```boss``` を出現させます。（この条件分岐がないと、 ```boss``` がいるのに ```boss``` が重複出現してしまうことがありえます。）

また、 ```boss``` が出現している ```else``` 節のほうですが、ここでは ```boss``` が倒れたかどうかを調べます。倒れたときは、ステージを次に進めます。

ただし、ステージ3はないので、そのステージに進まないように条件 ```stage < 2``` を加えておく必要があります。

### 作ったステージを試してみる

作ったステージを実際にメインメソッドで試してみましょう。

```Program.cs``` の ```Main``` メソッドに以下のようにコードを書き加えてください。

```diff
+            // StageManagerインスタンスへの参照を持っておく
+            StageManager stageManager = StageManager.Instance;

+            // StageManagerインスタンスを初期化する
+            stageManager.init(layer, player);

			// シーンを切り替える。
            ace.Engine.ChangeScene(scene);

            // ACEのウインドウが閉じられていないか確認する。
            while (ace.Engine.DoEvents())
            {
                // aceを更新する。
                ace.Engine.Update();

+                // stageManagerを更新する
+                stageManager.onUpdate();
            }
```

実行すると作ったステージを体験できると思います。ステージ0しか実装していないため、ステージ0のボスをクリアした場合、ステージ1のボスが続けてでることと思います。```initStage1```が編集されていないのが原因でしょう。

### まとめ

これにてステージを作ることができました。あとは```initStage```について考えればいいので、新しくステージを考えるのが楽になったと思います。


### コード例

Program.cs Main
```cs
			// StageManagerインスタンスへの参照を持っておく
			StageManager stageManager = StageManager.Instance;

			// StageManagerインスタンスを初期化する
            stageManager.init(layer, player);

			// シーンを切り替える。
            ace.Engine.ChangeScene(scene);

            // ACEのウインドウが閉じられていないか確認する。
            while (ace.Engine.DoEvents())
            {
                // aceを更新する。
                ace.Engine.Update();

                // stageManagerを更新する
                stageManager.onUpdate();
            }
```

StageManager.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace STG
{
    public class StageManager
    {
        // 一度だけインスタンス化される
        public static StageManager Instance;

        // 敵の出現するレイヤーを持つ
        GameLayer gameLayer;

        // プレイヤーの参照を持つ
        Player player;
        
        // ステージの最後にボスが出る
        Boss boss;

        // ステージ数を管理
        int stage;

        // ゲームの経過時間を管理
        int count;

        // ステージごとに敵を入れておくキュー
        Queue<Enemy>[] enemyQueues = new Queue<Enemy>[3];

        static StageManager()
        {
            // 一度だけ呼ばれるコンストラクタ
            Instance = new StageManager();
        }

        public void init(GameLayer gameLayer, Player player)
        {
            // 敵を出現させるレイヤーを設定する
            this.gameLayer = gameLayer;

            // プレイヤーの参照を設定する
            this.player = player;

            // 最初のステージを0とする
            stage = 0;

            // ゲーム内のカウントを0にする
            count = 0;
            
            // ステージ0用の敵をセットする
            initStage0();

            // ステージ1用の敵をセットする
            initStage1();

            // ステージ2用の敵をセットする
            initStage2();
        }

        // ステージ0に出現する敵を設定する
        private void initStage0()
        {
            // enemyQueue[0]にQueue<Enemy>をインスタンス化する。このキューにステージ0の敵を入れておく。
            enemyQueues[0] = new Queue<Enemy>();

            // 敵を射出する速度 moveVelocity を設定しておく
            ace.Vector2DF moveVelocity = new ace.Vector2DF(2.0f, 0.0f);

            // 10回ループする
            for (int i = 0; i < 10; i++)
            {
                // 速度を60度の向きに
                moveVelocity.Degree = 60;

                // 左側に敵を出現させる
                enemyQueues[0].Enqueue(new StraightMovingEnemy(new ace.Vector2DF(100.0f, 0.0f), moveVelocity, player));
                
                // 速度を120度の向きに
                moveVelocity.Degree = 120;

                // 右側に敵を出現させる
                enemyQueues[0].Enqueue(new StraightMovingEnemy(new ace.Vector2DF(540.0f, 0.0f), moveVelocity, player));
            }

            // 20回ループする
            for (int i = 0; i < 20; i++)
            {
                // 速度を90度の向きに
                moveVelocity.Degree = 90;

                // 左側に敵を出現させる
                enemyQueues[0].Enqueue(new StraightMovingEnemy(new ace.Vector2DF(100.0f, 0.0f), moveVelocity, player));
            }

            // 20回ループする
            for (int i = 0; i < 20; i++)
            {
                // 速度を90度の向きに
                moveVelocity.Degree = 90;

                // 右側に敵を出現させる
                enemyQueues[0].Enqueue(new StraightMovingEnemy(new ace.Vector2DF(540.0f, 0.0f), moveVelocity, player));
            }
        }
        private void initStage1()
        {
            // ステージ0同様に設定していく
            enemyQueues[1] = new Queue<Enemy>();
        }
        private void initStage2()
        {
            // ステージ0同様に設定していく
            enemyQueues[2] = new Queue<Enemy>();
        }


        // 自分で作ったonUpdateなので、メインループで呼ぶ必要がある
        public void onUpdate()
        {
            // ステージに対応するキューが空でないならば
            if (enemyQueues[stage].Count > 0)
            {
                // countが72の倍数の時に
                if (count % 72 == 0)
                {
                    // 敵を出現させる
                    gameLayer.AddObject(enemyQueues[stage].Dequeue());
                }
            }

            // そのステージの敵が出現し終わったら
            else
            {
                // ボスが出現してないときに
                if (boss == null)
                {
                    // ボスを出現させる
                    boss = new Boss(new ace.Vector2DF(320.0f, 0.0f), player);

                    // ボスをレイヤーに追加する
                    gameLayer.AddObject(boss);
                }

                else
                {
                    // ボスが倒れたとき
                    if (!boss.IsAlive)
                    {
                        // ステージが2未満の時
                        if (stage < 2)
                        {
                            // ボスを初期化しておいて
                            boss = null;

                            // ステージを先に進める
                            ++stage;
                        }
                    }
                }
            }
            // onUpdate ごとに count を進める
            ++count;
        }
    }
}

```