## 14. ボスを実装してみよう

### 概要

前章「 [13. ゲーム画面の背景を実装してみよう](13.md) 」では背景を扱うことができるようになりました。

本章では、ゲームの大きな要素にもなる「ボス」を実装します。本章で扱う「ボス」は、簡単のために以下の要件を満たすものとします。

* HPがある（一発の弾では倒れない）
* ランダムに動く
* 複数の攻撃パターンがある

雑魚敵と区別することができればそれは「ボス」と呼べるでしょう。これを「大ボス」へと昇華するには「ボスどうしの差別化」が必要となるはずですが、ここでは「ボス」を実装することに注力しようと思います。

なお、本章では C# における**乱数**を使用します。

[＠IT：.NET TIPS 乱数を生成するには？ - C#](http://www.atmarkit.co.jp/fdotnet/dotnettips/035random/random.html)


<!-- 
* ボステクスチャの用意
* （ボスを部位に分けてTexture2DのSrcを使う（矩形当たり判定を複数作る））
* HPゲージ実装(レイヤーを分ける)
* （特殊エフェクトの用意）
* 特殊攻撃パターンの用意 -->

### ボスのクラスを作る

```Enemy``` クラスを継承した ```Boss``` クラスを作りたいと思います。

まずは、 ```Boss.cs``` ファイルをプロジェクトに追加して以下のようなコードを用意しましょう。

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace STG
{
    public class Boss : Enemy
    {
        public Boss(ace.Vector2DF pos, Player player)
            : base(pos, player)
        {
            // base(pos, player) のところで、Enemyクラスのコンストラクタは実行されています

            // Boss のテクスチャを上書きする
            Texture = ace.Engine.Graphics.CreateTexture2D("Resources/Character_5.png");

            // CenterPositionを上書きする
            CenterPosition = new ace.Vector2DF(Texture.Size.X / 2.0f, Texture.Size.Y / 2.0f);
        }
    }
}
```

```Boss``` クラスは ```Enemy``` クラスを継承しました。 しかし、```Boss``` クラスでは、画像とその中心位置が変わるので、 ```Enemy``` クラスのコンストラクタが実行された後に、 ```Boss``` クラスの画像とその中心位置を更新する必要があります。上記のコンストラクタで行われているのはその処理です。

次は、 ```Program.cs``` の ```Main``` メソッドでインスタンス化を行います。今回は ```Boss``` に焦点を当てたいので、 ```Enemy``` 
クラスのインスタンスを生成せずに、 ```Boss``` クラスのインスタンスだけを生成するようにします。

```Program.cs``` の ```Main``` メソッドを以下のように編集しましょう

```diff
class Program
    {
        static void Main(string[] args)
        {

			（省略）

			// 自機オブジェクトを生成する。
            Player player = new Player();

            // レイヤーに自機オブジェクトを追加する。
            layer.AddObject(player);
           
-            //敵オブジェクトを生成する。
-            GentlyMovingEnemy gentlyMovingEnemy = new GentlyMovingEnemy(new ace.Vector2DF(320.0f, 100.0f), player);
+            //Bossクラスのインスタンスを生成する。
+            Boss boss = new Boss(new ace.Vector2DF(320.0f, 100.0f), player);

-            //敵オブジェクトを追加する。
-            layer.AddObject(gentlyMovingEnemy);
+            //レイヤーにボスを追加する
+            layer.AddObject(boss);

            // シーンを切り替える。
            ace.Engine.ChangeScene(scene);

            （省略）

        }
    }
```

問題がなければ、実行してボスが表示できているはずです。
これで、0段階目は終了です。

### ボスのHPの実装

「ボスは弾に当たればダメージを受けてHPが減る」ということを念頭に置きましょう。その上で以下のような手順を踏めばボスのHPゲージを表示することができそうです。

1. ボスの最大HPを定義する
2. 最大HPに応じてHPゲージを描画する
3. ダメージを受けた場合に右からHPゲージを消していく
4. HPが0以下になったらボス撃破

#### 最大HPの定義

まず、1.ですがこれを ```maxHP``` としておきましょう。これとは別に、ボスの現在のHPを持っておく必要があるので、これを ```HP``` とします。

使い方としては、 ```maxHP``` にはあらかじめ整数を代入しておいて定数として扱い、 ```Boss``` クラスのコンストラクタで、初めて ```HP``` に ```maxHP``` が代入されるという方式にしたいと思います。

これを実装するため、 ```Boss``` クラスに以下のコードを追加します。

```diff
namespace STG
{
    public class Boss : Enemy
    {
+        // HP関連の宣言
+        // maxHPは定数として代入しておく
+        private const int maxHP = 3000;
+        private int HP;

        public Boss(ace.Vector2DF pos, Player player)
            : base(pos, player)
        {
            // base(pos, player) のところで、Enemyクラスのコンストラクタは実行されています

            // Boss のテクスチャを上書きする
            Texture = ace.Engine.Graphics.CreateTexture2D("Resources/Character_5.png");

            // CenterPositionを上書きする
            CenterPosition = new ace.Vector2DF(Texture.Size.X / 2.0f, Texture.Size.Y / 2.0f);

+            // HPを設定する
+            HP = maxHP;
        }
    }
}
```

これで、最大HPを定義することができました。次はHPの可視化です。

#### HPゲージの描画

今回はディテールは拘らず、簡単にHPゲージを実装してみることにします。

ACE の `TextureObject2D` が有する `DrawLineAdditionally` というメソッドを利用します。

では、HPゲージに必要なものを用意していきます。

* ゲージの長さ : HPの割合
* ゲージの色 : 赤
* ゲージの位置 : 画面上部
* ゲージの太さ : 20px

こんな感じでHPゲージを作っていこうと思います。

まず、```Boss``` クラスにHP関連の宣言を追加しましょう

```diff
        // HP関連の宣言
        // maxHP, diameterHPLine は定数として代入しておく
        private const int maxHP = 3000;
        private int HP;
+        private int HPlength;
+        private ace.Color red = new Color(255, 0, 0, 255);
+        private ace.Vector2DF startHPLine;
+        private ace.Vector2DF destHPLine;
+        private const int diameterHPLine = 20;
```

ここでは、HPゲージの長さ・色・左端・右端・を ```HPlength```, ```red```, ```startHPLine```, ```destHPLine``` として定義しています。

ここで、ACE が持つ ```Color``` というクラスを利用して色を設定しています。コンストラクタに渡す引数は、順番に「r値, g値, b値, アルファ値」です。最大値は255となっています。

次に、HPゲージを描画できるように ```OnUpdate()``` を実装してみます。

```cs
protected override void OnUpdate()
        {
            // HPの表示

            // 表示するHPゲージの長さを計算する
            HPlength = (ace.Engine.WindowSize.X - 10) * HP / maxHP;

            // HPゲージの左端を設定する
            startHPLine = new ace.Vector2DF(5, 15);

            // HPゲージの右端を計算する
            destHPLine = startHPLine + new ace.Vector2DF(HPlength, 0);

            // HPゲージを描画する
            DrawLineAdditionally(startHPLine, destHPLine, red, diameterHPLine, ace.AlphaBlendMode.Blend, 30);
        }
```

まず、```HPlength``` の値を定めます。予め、画面の横のサイズから少し減らした値にHPの割合をかけてこれを長さとします。

次に、```startHPLine``` の値を定めます。これは、描画される線の太さを考慮して(5, 15)と定めています。```destHPLine``` はこれに ```HPLength``` だけ横に伸ばした値を定めます。

そして、```DrawLineAdditionally``` です。引数にとる値は順番に、「開始位置、終了位置、色、線の直径、描画方法、描画優先度」です。

描画優先度を変えると、そのレイヤーでの描画順番を変えることができます。ここではゲームに登場するキャラクター達よりは上に配置するように ```30``` と、仮に設定しています。

これを実行してみると、赤いHPゲージが表示されているのが分かると思います。実際に ```OnUpdate()``` 中に ```HP``` を減らす処理を書いてみるとHPゲージが減る様子を観察することができるでしょう。

#### ボスに当たり判定をつける

弾が当たったらHPが減るという処理を実装すれば問題ありません。

さて、HPゲージの実装は終わりにして、ボスを動かしていきましょう。

（HP0で消滅）

### ボスをランダムに移動させる

ボスの基本的な移動を実装します。  

HPを持っているボスは簡単に倒れないですし、単調な動きをして勝手に画面外に出ることもありません。かといって、定位置に固定しておくわけにもいきません。  

できるだけ不自然さを排した動きを実現したいと思います。　  

1. ```Random``` クラスのオブジェクトを用いて乱数を生成する
2. 1. の方法で、ランダムな方向ベクトルを定める。
3. 2. で求めた方向ベクトルに従う速度ベクトルを決める。
4. 一定時間が経過したら 2. に戻る

この手順を踏めば少なくとも不自然ではない移動が実装できます。各々思うところがあれば微調整を加えてもいいと思います。

#### ランダムに位置を決める

乱数を使用するためには```Random```クラスのオブジェクトを生成する必要があります。

```cs
Random rand = new Random();
int randumNumber = rand.Next();
```

この例では、```rand``` という ```Random```クラスのオブジェクトを生成して、 ```rand.Next()``` で整数の乱数を生成しています。この乱数を ```randumNumber``` に設定しているという具合です。

この乱数生成の方法を用いてボスの位置ベクトルをランダムに決めてみましょう。

```Boss.cs``` の変更部分は以下の通りです。

```diff
```

ボスが影分身するように見えますね。これに ```count``` がnの倍数の時だけ ```Position``` を更新するように設定してみます。以下は n が　? の場合です。

```diff
```

今度は動きこそ落ち着きましたが、非連続的にボスが移動するのは基本的とは呼べないでしょう。連続した動きを目指してみます

#### ランダムに速度を決める

位置に乱数を使うのではなく、速度に乱数を使うようにしてみましょう。この時、毎回の更新ごとにボスの位置に速度が足されることが前提になっているので気を付けましょう。

速度ベクトルを乱数で決めてみます。  
速度ベクトルの向きは、乱数で生成した目標地点に向くようにしてみましょう。  
速度ベクトルの大きさは、単位ベクトルと同じ1としておきましょう。

```Boss.cs``` の変更部分は以下の通りです。

```diff
```

グネグネ動く気持ち悪い物体になってしまいました。不自然なので、```count``` がnの倍数の時だけ ```Position``` を更新するように設定してみます。以下は n が ? の場合です。

```diff
```

ある程度安定して動いてくれるようになったと思います。しかし、画面外に出てしまいそうな動き方をします。できるだけ画面内に目標地点を設定してはいますが、外に出てしまうかもしれません。外に出てしまいそうな場合は方向転換してもらいましょう。


この辺は ```EnemyBullet``` クラスに見る画面外処理と似ています。参考にしましょう。

```diff
```

次は速度ベクトルの大きさに乱数を用いてみましょう。大きさがずっと1ではあまりにも平坦なのでその幅を持たせようという寸法です。

```rand.Next()``` では整数しか生成できませんでしたが、```rand.NextDouble()``` では0から1までの小数の乱数を生成することができます。これを用いれば速度ベクトルの大きさを微調整することも可能です。

この ```rand.NextDouble()``` を用いて、自分で決めた最小値 ```min``` と最大値 ```max``` に従う範囲の小数の乱数を生成するようにしてみます。


```diff
```

実行してみると、速度ベクトルを自由に変えながらボスが移動しているのが分かると思います。あとは自分で値を微調整して、ボスに合う速度ベクトルの大きさの範囲を決めてみるといいでしょう。

### ボスに複数の攻撃パターンを持たせる

HPに応じて攻撃パターンを変えるようにしてみましょう。HPが4分の3、半分、4分の1になる時にパターンが変わるとして、4パターン用意しましょう。

敵の攻撃パターンについては [Tips]() で特集されています。ここでは気を楽にして、複数の攻撃パターンを持つ「ボス」ができる過程を考えましょう。

#### 雑魚敵の攻撃を流用する

雑魚敵が単体で使ってもそうでもないが、ボスが使えば一味変わるというイメージで実装したいと思います。

ショットを複数の部位で打たせて厚みを持たせてみようと思います。

一応 ```Enemy``` クラスにも複数のショットが用意されていますが、弾の角度や発射位置を微調整したいので、 ```Boss``` クラスに新しくショットを定義していきます。単発のショットのやってることはほぼ同じで、それを組み合わせるだけです。

2つのショットを ```Boss``` クラスで定義します。

```diff
```

1つ目は ```AroundShot``` に工夫を加えたもので、手前の2門から5発ずつ発射されます。微妙に発射位置がずれることで弾が交差して厚みを持つ効果を狙ってます。それに加え真ん中から2発。わざと少しずらした弾を発射します。

2つ目は ```VortexShot``` を利用したもので、曲線でプレイヤーを挟むような形をつくっています。構造は簡単で、奧の2門から互いに違う向きの回転で ```VortexShot``` をしているだけです。

#### レーザーを作ってみる

レーザーの解説が難しくなってしまったので [Tips]() に載せることになりました。追加するソースコードは以下の通りです。

新しく ```Laser.cs``` を作り以下のように記述してください。
```cs
```

```Boss.cs```には以下のコードが追加されます。

```diff
```

無事レーザーが表示されれば問題ありません。

#### HPに応じて攻撃パターンを変える

HPの割合によるif else if hogehoge






