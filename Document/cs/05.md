## 05. ソースコードを整理してみよう

### 概要

前章で、キャラクターが弾を撃つようになりました。しかし、ソースコードがどんどん長くなっており、段々わかりにくくなってきています。
今回はソースコードを整理して、キャラクターと弾の処理を個別に管理できるようにしましょう。

また、現在の弾は画面外に出ても消えずに残っているため、弾を撃ちすぎるとどんどん処理が増え、アプリケーションが重くなってしまいます。
そこで、ソースコードを整理した後に、画面外に出た弾を消す処理も加えてみましょう。

本章で使用するC#の機能は下記のWebページに説明されています。説明内容のうち一部分のみを使用しますので、どこを読めばいいかも併せて示します。

* [C# によるプログラミング入門 - 関数](http://ufcpp.net/study/csharp/st_function.html) 

概要、関数定義

* [C# によるプログラミング入門 - 継承](http://ufcpp.net/study/csharp/oo_inherit.html) 

クラスの継承

### 事前準備

今回も、自分でプロジェクトの設定はせずに、設定済みのプロジェクトをダウンロードして使用します。

[プロジェクト(Windows)](Projects/STG04.zip?raw=true)

[プロジェクト(Mac)](Projects/Mac/STG04.zip?raw=true)

[DLL(Windows)](Common/DLL.zip?raw=true)

[DLL(Mac)](Common/Mac/DLL.zip?raw=true)

[リソース](Common/Resources.zip?raw=true)

### メソッドを使用してキャラクターのソースコードを整理する

プレイヤーと弾を移動させるソースコードを`while`ループの中に追加したため、`while`ループの中が長くなってしまいました。
現在はまだプレイヤーの移動と弾の発射だけですが、これから敵を加えていくと、どんどん長くなっていきます。最終的には、開発者本人も読めなくなってしまいます。
そこで、メソッドを使用してソースコードを整理します。
プレイヤーの移動処理と画面外に出ないようにする処理をメソッドに抜き出しましょう。

```diff
class Program
{

+	static void MovePlayer(ace.TextureObject2D player)
+	{
+		// もし、上ボタンが押されていたら、位置に(0,-1)を足す。
+		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Up) == ace.KeyState.Hold)
+		{
+			player.Position = player.Position + new ace.Vector2DF(0, -1);
+		}

+		// もし、下ボタンが押されていたら、位置に(0,+1)を足す。
+		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Down) == ace.KeyState.Hold)
+		{
+			player.Position = player.Position + new ace.Vector2DF(0, +1);
+		}

+		// もし、左ボタンが押されていたら、位置に(-1,0)を足す。
+		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Left) == ace.KeyState.Hold)
+		{
+			player.Position = player.Position + new ace.Vector2DF(-1, 0);
+		}

+		// もし、左ボタンが押されていたら、位置に(+1,0)を足す。
+		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Right) == ace.KeyState.Hold)
+		{
+			player.Position = player.Position + new ace.Vector2DF(+1, 0);
+		}
+

+		// プレイヤーの位置を取得する。
+		ace.Vector2DF position = player.Position;

+		// プレイヤーの位置を、(テクスチャの大きさ/2)～(ウインドウの大きさ-テクスチャの大きさ/2)の範囲に制限する。
+		position.X = ace.MathHelper.Clamp(position.X, ace.Engine.WindowSize.X - player.Texture.Size.X / 2.0f, player.Texture.Size.X / 2.0f);
+		position.Y = ace.MathHelper.Clamp(position.Y, ace.Engine.WindowSize.Y - player.Texture.Size.Y / 2.0f, player.Texture.Size.Y / 2.0f);

+		// プレイヤーの位置を設定する。
+		player.Position = position;
+	}

	[STAThread]
	static void Main(string[] args)
	{
		// Altseedを初期化する。
		ace.Engine.Initialize("STG", 640, 480, new ace.EngineOption());

		// プレイヤーのインスタンスを生成する。
		ace.TextureObject2D player = new ace.TextureObject2D();

		// 画像を読み込み、プレイヤーのインスタンスに画像を設定する。
		player.Texture = ace.Engine.Graphics.CreateTexture2D("Resources/Player.png");

		// プレイヤーのインスタンスに画像の中心位置を設定する。
		player.CenterPosition = new ace.Vector2DF(player.Texture.Size.X / 2.0f, player.Texture.Size.Y / 2.0f);

		// エンジンにプレイヤーのインスタンスを追加する。
		ace.Engine.AddObject2D(player);

		// プレイヤーのインスタンスの位置を変更する。
		player.Position = new ace.Vector2DF(320, 240);

		// リストのインスタンスを生成する。
		List<ace.TextureObject2D> bullets = new List<ace.TextureObject2D>();

		// Altseedのウインドウが閉じられていないか確認する。
		while (ace.Engine.DoEvents())
		{
			// もし、Escキーが押されていたらwhileループを抜ける。
			if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Escape) == ace.KeyState.Push)
			{
				break;
			}

-			// もし、上ボタンが押されていたら、位置に(0,-1)を足す。
-			if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Up) == ace.KeyState.Hold)
-			{
-				player.Position = player.Position + new ace.Vector2DF(0, -1);
-			}
-
-			// もし、下ボタンが押されていたら、位置に(0,+1)を足す。
-			if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Down) == ace.KeyState.Hold)
-			{
-				player.Position = player.Position + new ace.Vector2DF(0, +1);
-			}
-
-			// もし、左ボタンが押されていたら、位置に(-1,0)を足す。
-			if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Left) == ace.KeyState.Hold)
-			{
-				player.Position = player.Position + new ace.Vector2DF(-1, 0);
-			}
-
-			// もし、左ボタンが押されていたら、位置に(+1,0)を足す。
-			if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Right) == ace.KeyState.Hold)
-			{
-				player.Position = player.Position + new ace.Vector2DF(+1, 0);
-			}

			// もし、Zキーを押したら{}内の処理を行う。
			if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Z) == ace.KeyState.Push)
			{
				// 弾のインスタンスを生成する。
				ace.TextureObject2D bullet = new ace.TextureObject2D();

				// 画像を読み込み、弾のインスタンスに画像を設定する。
				bullet.Texture = ace.Engine.Graphics.CreateTexture2D("Resources/PlayerBullet.png");

				// 弾のインスタンスに画像の中心位置を設定する。
				bullet.CenterPosition = new ace.Vector2DF(bullet.Texture.Size.X / 2.0f, bullet.Texture.Size.Y / 2.0f);

				// 弾のインスタンスをエンジンに追加する。
				ace.Engine.AddObject2D(bullet);

				// 弾のインスタンスの位置を設定する。
				bullet.Position = player.Position + new ace.Vector2DF(0, -30);

				// 弾のインスタンスをリストに追加する。
				bullets.Add(bullet);
			}

			// bulletsに格納されている弾を移動させる
			for (int i = 0; i < bullets.Count; i++)
			{
				// 弾の座標を変更する
				bullets[i].Position = bullets[i].Position + new ace.Vector2DF(0, -2);
			}

-			// プレイヤーの位置を取得する。
-			ace.Vector2DF position = player.Position;
-
-			// プレイヤーの位置を、(テクスチャの大きさ/2)～(ウインドウの大きさ-テクスチャの大きさ/2)の範囲に制限する。
-			position.X = ace.MathHelper.Clamp(position.X, ace.Engine.WindowSize.X - player.Texture.Size.X / 2.0f, player.Texture.Size.X / 2.0f);
-			position.Y = ace.MathHelper.Clamp(position.Y, ace.Engine.WindowSize.Y - player.Texture.Size.Y / 2.0f, player.Texture.Size.Y / 2.0f);
-
-			// プレイヤーの位置を設定する。
-			player.Position = position;

+			// プレイヤーを移動する。
+			MovePlayer(player);

			// Altseedを更新する。
			ace.Engine.Update();
		}

		// Altseedの終了処理をする。
		ace.Engine.Terminate();
	}
}

```

以下のメソッドを追加しました。

```C#
static void MovePlayer(ace.TextureObject2D player)
```

`MovePlayer`メソッドは`player`の移動処理と画面外に出ないようにする処理を行います。
`Main`メソッドから`player`を渡して`MovePlayer`メソッドを呼び出しています。

### 継承を使用してキャラクターのソースコードを整理する

次に、クラスの継承を使用してソースコードを整理します。

```diff
+	class Player : ace.TextureObject2D
+	{
+	}

	class Program
	{
-		static void MovePlayer(ace.TextureObject2D player)
+		static void MovePlayer(Player player)
		{

			// 省略

		}

		[STAThread]
		static void Main(string[] args)
		{
			// Altseedを初期化する。
			ace.Engine.Initialize("STG", 640, 480, new ace.EngineOption());

			// プレイヤーのインスタンスを生成する。
-			ace.TextureObject2D player = new ace.TextureObject2D();
+			Player player = new Player();

			// 省略

		}
	}
```

以前、 ``` ace.TextureObject2D ```は設計図だと述べました。
C#の継承という機能を使用することで、元の設計図を利用して新たな設計図を作ることができます。

```C#
class Player : ace.TextureObject2D
```

ここでは、元の設計図である`ace.TextureObject2D`を利用して、新たな設計図である`Player`クラスを作っています。
設計図を元に設計図を作成することを、クラスの「継承」と呼びます。

ただし、新たな設計図といっても、新しい機能はまだ何も追加していません。
それでは、先ほど抜き出した`MovePlayer`メソッドを`Player`クラスに移しましょう。

```diff
class Player : ace.TextureObject2D
{
+	public void Move()
+	{
+		// もし、上ボタンが押されていたら、位置に(0,-1)を足す。
+		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Up) == ace.KeyState.Hold)
+		{
+			Position = Position + new ace.Vector2DF(0, -1);
+		}
+
+		// もし、下ボタンが押されていたら、位置に(0,+1)を足す。
+		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Down) == ace.KeyState.Hold)
+		{
+			Position = Position + new ace.Vector2DF(0, +1);
+		}
+
+		// もし、左ボタンが押されていたら、位置に(-1,0)を足す。
+		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Left) == ace.KeyState.Hold)
+		{
+			Position = Position + new ace.Vector2DF(-1, 0);
+		}
+
+		// もし、左ボタンが押されていたら、位置に(+1,0)を足す。
+		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Right) == ace.KeyState.Hold)
+		{
+			Position = Position + new ace.Vector2DF(+1, 0);
+		}
+
+
+		// プレイヤーの位置を取得する。
+		ace.Vector2DF position = Position;
+
+		// プレイヤーの位置を、(テクスチャの大きさ/2)～(ウインドウの大きさ-テクスチャの大きさ/2)の範囲に制限する。
+		position.X = ace.MathHelper.Clamp(position.X, ace.Engine.WindowSize.X - Texture.Size.X / 2.0f, Texture.Size.X / 2.0f);
+		position.Y = ace.MathHelper.Clamp(position.Y, ace.Engine.WindowSize.Y - Texture.Size.Y / 2.0f, Texture.Size.Y / 2.0f);
+
+		// プレイヤーの位置を設定する。
+		Position = position;
+	}
}

class Program
{
-	static void MovePlayer(Player player)
-	{
-		// もし、上ボタンが押されていたら、位置に(0,-1)を足す。
-		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Up) == ace.KeyState.Hold)
-		{
-			player.Position = player.Position + new ace.Vector2DF(0, -1);
-		}

-		// もし、下ボタンが押されていたら、位置に(0,+1)を足す。
-		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Down) == ace.KeyState.Hold)
-		{
-			player.Position = player.Position + new ace.Vector2DF(0, +1);
-		}

-		// もし、左ボタンが押されていたら、位置に(-1,0)を足す。
-		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Left) == ace.KeyState.Hold)
-		{
-			player.Position = player.Position + new ace.Vector2DF(-1, 0);
-		}

-		// もし、左ボタンが押されていたら、位置に(+1,0)を足す。
-		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Right) == ace.KeyState.Hold)
-		{
-			player.Position = player.Position + new ace.Vector2DF(+1, 0);
-		}
-

-		// プレイヤーの位置を取得する。
-		ace.Vector2DF position = player.Position;

-		// プレイヤーの位置を、(テクスチャの大きさ/2)～(ウインドウの大きさ-テクスチャの大きさ/2)の範囲に制限する。
-		position.X = ace.MathHelper.Clamp(position.X, ace.Engine.WindowSize.X - player.Texture.Size.X / 2.0f, player.Texture.Size.X / 2.0f);
-		position.Y = ace.MathHelper.Clamp(position.Y, ace.Engine.WindowSize.Y - player.Texture.Size.Y / 2.0f, player.Texture.Size.Y / 2.0f);

-		// プレイヤーの位置を設定する。
-		player.Position = position;
-	}

	[STAThread]
	static void Main(string[] args)
	{

		// 省略

		// Altseedのウインドウが閉じられていないか確認する。
		while (ace.Engine.DoEvents())
		{

			// 省略

			// プレイヤーを移動する。
-			MovePlayer(player);
+			player.Move();

			// Altseedを更新する。
			ace.Engine.Update();
		}

		// Altseedの終了処理をする。
		ace.Engine.Terminate();
	}
}
```

`MovePlayer`メソッドを`Player`クラスの`Move`メソッドに移しました。
`Player`クラスのメソッドになったことで、自分自身の設定である`Position`や`Texture`をそのまま記述しています。
また、`Main`からのメソッドの呼び出し方も変わっています。

つづいて、Altseedの`Update`の機能を使って自動的に`Player`クラスの更新処理を行うようにしましょう。

```diff
class Player : ace.TextureObject2D
{
-	public void Move()
+	protected override void OnUpdate()
	{
		// 省略
	}
}

class Program
{
	[STAThread]
	static void Main(string[] args)
	{

		// 省略

		// Altseedのウインドウが閉じられていないか確認する。
		while (ace.Engine.DoEvents())
		{

			// 省略

-			// プレイヤーを移動する。
-			player.Move();

			// Altseedを更新する。
			ace.Engine.Update();
		}

		// Altseedの終了処理をする。
		ace.Engine.Terminate();
	}
}
```

`OnUpdate`は、Altseedが更新された時(ace.Engine.Updateが実行された時)に実行されるメソッドです。
ここでは、`Move`の代わりに`OnUpdate`を使うことで、Altseedが更新される度にインスタンス自身を移動させています。

```C#
protected override void OnUpdate()
```

`override`は継承を使用してメソッドの動作を書き換えるC#の機能です。
`OnUpdate`と記述するだけでなく、`override`も記述しないと正しく動作しません。
`override`に関して詳しく知りたい方は概要に記述されているリンクの先を見てください。

### 継承を使用して弾のソースコードを整理する

今度は弾のソースコードを整理していきます。弾のクラスをソースコードに追加しましょう。

```diff

+class Bullet : ace.TextureObject2D
+{
+	protected override void OnUpdate()
+	{
+		Position = Position + new ace.Vector2DF(0, -2);
+	}
+}

class Player : ace.TextureObject2D
{
	protected override void OnUpdate()
	{
		// もし、上ボタンが押されていたら、位置に(0,-1)を足す。
		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Up) == ace.KeyState.Hold)
		{
			Position = Position + new ace.Vector2DF(0, -1);
		}
	
		// もし、下ボタンが押されていたら、位置に(0,+1)を足す。
		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Down) == ace.KeyState.Hold)
		{
			Position = Position + new ace.Vector2DF(0, +1);
		}
	
		// もし、左ボタンが押されていたら、位置に(-1,0)を足す。
		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Left) == ace.KeyState.Hold)
		{
			Position = Position + new ace.Vector2DF(-1, 0);
		}
	
		// もし、左ボタンが押されていたら、位置に(+1,0)を足す。
		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Right) == ace.KeyState.Hold)
		{
			Position = Position + new ace.Vector2DF(+1, 0);
		}
	
		
		// プレイヤーの位置を取得する。
		ace.Vector2DF position = Position;
	
		// プレイヤーの位置を、(テクスチャの大きさ/2)～(ウインドウの大きさ-テクスチャの大きさ/2)の範囲に制限する。
		position.X = ace.MathHelper.Clamp(position.X, ace.Engine.WindowSize.X - Texture.Size.X / 2.0f, Texture.Size.X / 2.0f);
		position.Y = ace.MathHelper.Clamp(position.Y, ace.Engine.WindowSize.Y - Texture.Size.Y / 2.0f, Texture.Size.Y / 2.0f);
	
		// プレイヤーの位置を設定する。
		Position = position;
		
	}
}

class Program
{
	[STAThread]
	static void Main(string[] args)
	{
		// Altseedを初期化する。
		ace.Engine.Initialize("STG", 640, 480, new ace.EngineOption());

		// プレイヤーのインスタンスを生成する。
		Player player = new Player();
		
		// 画像を読み込み、プレイヤーのインスタンスに画像を設定する。
		player.Texture = ace.Engine.Graphics.CreateTexture2D("Resources/Player.png");

		// プレイヤーのインスタンスに画像の中心位置を設定する。
		player.CenterPosition = new ace.Vector2DF(player.Texture.Size.X / 2.0f, player.Texture.Size.Y / 2.0f);

		// エンジンにプレイヤーのインスタンスを追加する。
		ace.Engine.AddObject2D(player);

		// プレイヤーのインスタンスの位置を変更する。
		player.Position = new ace.Vector2DF(320, 240);

-		// リストを生成する。
-		List<ace.TextureObject2D> bullets = new List<ace.TextureObject2D>();

		// Altseedのウインドウが閉じられていないか確認する。
		while (ace.Engine.DoEvents())
		{
			// もし、Escキーが押されていたらwhileループを抜ける。
			if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Escape) == ace.KeyState.Push)
			{
				break;
			}

			// もし、Zキーを押したら{}内の処理を行う。
			if(ace.Engine.Keyboard.GetKeyState(ace.Keys.Z) == ace.KeyState.Push)
			{

				// 弾のインスタンスを生成する。
-				ace.TextureObject2D bullet = new ace.TextureObject2D();
+				Bullet bullet = new Bullet();
			
				// 画像を読み込み、弾のインスタンスに画像を設定する。
				bullet.Texture = ace.Engine.Graphics.CreateTexture2D("Resources/PlayerBullet.png");

				// 弾のインスタンスに画像の中心位置を設定する。
				bullet.CenterPosition = new ace.Vector2DF(bullet.Texture.Size.X / 2.0f, bullet.Texture.Size.Y / 2.0f);			

				// 弾のインスタンスをエンジンに追加する。
				ace.Engine.AddObject2D(bullet);
				
				// 弾のインスタンスの位置を設定する。
				bullet.Position = player.Position + new ace.Vector2DF(0, -30);

-				// 弾のインスタンスをリストに追加する。
-				bullets.Add(bullet);
			}

-			// bulletsに格納されている弾を移動させる
-			for (int i = 0; i < bullets.Count; i++)
-			{
-				// 弾の座標を変更する
-				bullets[i].Position = bullets[i].Position + new ace.Vector2DF(0, -2);
-			}

			// Altseedを更新する。
			ace.Engine.Update();
		}

		// Altseedの終了処理をする。
		ace.Engine.Terminate();
	}
}

```

```
class Bullet : ace.TextureObject2D
{
	protected override void OnUpdate()
	{
		Position = Position + new ace.Vector2DF(0, -2);
	}
}
```

追加したら、Listに関係するソースコードを削除しましょう。

そして、

```ace.TextureObject2D bullet = new ace.TextureObject2D(); ```

を

```Bullet bullet = new Bullet(); ```

に書き換えます。

そうすると、bulletは弾クラスのインスタンスになり、更新するたびに弾自身が自分で移動するようになります。
そのため、Listを使って外部から、インスタンスを移動させる必要がなくなります。

### 弾を撃つ処理を移動させる

弾を撃っているのはプレイヤーなので、弾を生成する処理をプレイヤークラスに移動させます。

以下の弾を生成するコードをPlayerクラスのOnUpdateメソッドに追加します。

```diff

class Bullet : ace.TextureObject2D
{
	protected override void OnUpdate()
	{
		Position = Position + new ace.Vector2DF(0, -2);
	}
}

class Player : ace.TextureObject2D
{
	protected override void OnUpdate()
	{
		// もし、上ボタンが押されていたら、位置に(0,-1)を足す。
		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Up) == ace.KeyState.Hold)
		{
			Position = Position + new ace.Vector2DF(0, -1);
		}
	
		// もし、下ボタンが押されていたら、位置に(0,+1)を足す。
		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Down) == ace.KeyState.Hold)
		{
			Position = Position + new ace.Vector2DF(0, +1);
		}
	
		// もし、左ボタンが押されていたら、位置に(-1,0)を足す。
		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Left) == ace.KeyState.Hold)
		{
			Position = Position + new ace.Vector2DF(-1, 0);
		}
	
		// もし、左ボタンが押されていたら、位置に(+1,0)を足す。
		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Right) == ace.KeyState.Hold)
		{
			Position = Position + new ace.Vector2DF(+1, 0);
		}
	
+		// もし、Zキーを押したら{}内の処理を行う。
+		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Z) == ace.KeyState.Push)
+		{
+			// 弾のインスタンスを生成する。
+			Bullet bullet = new Bullet();
+		
+			// 画像を読み込み、弾のインスタンスに画像を設定する。
+			bullet.Texture = ace.Engine.Graphics.CreateTexture2D("Resources/PlayerBullet.png");
+
+			// 弾のインスタンスに画像の中心位置を設定する。
+			bullet.CenterPosition = new ace.Vector2DF(bullet.Texture.Size.X / 2.0f, bullet.Texture.Size.Y / 2.0f);
+		
+			// 弾のインスタンスをエンジンに追加する。
+			ace.Engine.AddObject2D(bullet);
+
+			// 弾のインスタンスの位置を設定する。
+			bullet.Position = Position + new ace.Vector2DF(0, -30);
+		}
		
		// プレイヤーの位置を取得する。
		ace.Vector2DF position = Position;
	
		// プレイヤーの位置を、(テクスチャの大きさ/2)～(ウインドウの大きさ-テクスチャの大きさ/2)の範囲に制限する。
		position.X = ace.MathHelper.Clamp(position.X, ace.Engine.WindowSize.X - Texture.Size.X / 2.0f, Texture.Size.X / 2.0f);
		position.Y = ace.MathHelper.Clamp(position.Y, ace.Engine.WindowSize.Y - Texture.Size.Y / 2.0f, Texture.Size.Y / 2.0f);
	
		// プレイヤーの位置を設定する。
		Position = position;
		
	}
}

class Program
{
	[STAThread]
	static void Main(string[] args)
	{
		// Altseedを初期化する。
		ace.Engine.Initialize("STG", 640, 480, new ace.EngineOption());

		// プレイヤーのインスタンスを生成する。
		Player player = new Player();
		
		// 画像を読み込み、プレイヤーのインスタンスに画像を設定する。
		player.Texture = ace.Engine.Graphics.CreateTexture2D("Resources/Player.png");

		// プレイヤーのインスタンスに画像の中心位置を設定する。
		player.CenterPosition = new ace.Vector2DF(player.Texture.Size.X / 2.0f, player.Texture.Size.Y / 2.0f);

		// エンジンにプレイヤーのインスタンスを追加する。
		ace.Engine.AddObject2D(player);

		// プレイヤーのインスタンスの位置を変更する。
		player.Position = new ace.Vector2DF(320, 240);

		// Altseedのウインドウが閉じられていないか確認する。
		while (ace.Engine.DoEvents())
		{
			// もし、Escキーが押されていたらwhileループを抜ける。
			if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Escape) == ace.KeyState.Push)
			{
				break;
			}

-			// もし、Zキーを押したら{}内の処理を行う。
-			if(ace.Engine.Keyboard.GetKeyState(ace.Keys.Z) == ace.KeyState.Push)
-			{
-				// 弾のインスタンスを生成する。
-				Bullet bullet = new Bullet();
-			
-				// 画像を読み込み、弾のインスタンスに画像を設定する。
-				bullet.Texture = ace.Engine.Graphics.CreateTexture2D("Resources/PlayerBullet.png");
-
-				// 弾のインスタンスに画像の中心位置を設定する。
-				bullet.CenterPosition = new ace.Vector2DF(bullet.Texture.Size.X / 2.0f, bullet.Texture.Size.Y / 2.0f);			
-
-				// 弾のインスタンスをエンジンに追加する。
-				ace.Engine.AddObject2D(bullet);
-				
-				// 弾のインスタンスの位置を設定する。
-				bullet.Position = player.Position + new ace.Vector2DF(0, -30);
-			}

			// Altseedを更新する。
			ace.Engine.Update();
		}

		// Altseedの終了処理をする。
		ace.Engine.Terminate();
	}
}

```

そして、whileループから弾を生成する処理を消します。
挙動は変わらないですが、プレイヤーの挙動の殆どが、プレイヤークラスにまとまりました。
そしてwhileループの中はAltseedの更新のみになりました。

### クラスのコンストラクタを使用してコードを整理する。

大分、クラスに処理がまとまってきましたが、画像の読み込みと一番最初の座標の指定はクラス外から行われてました。ここをコンストラクタという機能を使って、
クラスの初期値を設定できるようにします。

```diff

class Bullet : ace.TextureObject2D
{
+	public Bullet(ace.Vector2DF position)
+	{
+		// 画像を読み込み、弾のインスタンスに画像を設定する。
+		Texture = ace.Engine.Graphics.CreateTexture2D("Resources/PlayerBullet.png");
+	
+		// 弾のインスタンスに画像の中心位置を設定する。
+		CenterPosition = new ace.Vector2DF(Texture.Size.X / 2.0f, Texture.Size.Y / 2.0f);
+
+		// 弾のインスタンスの位置を設定する。
+		Position = position;
+	}

	protected override void OnUpdate()
	{
		Position = Position + new ace.Vector2DF(0, -2);
	}
}

class Player : ace.TextureObject2D
{
+	public Player()
+	{
+		// 画像を読み込み、プレイヤーのインスタンスに画像を設定する。
+		Texture = ace.Engine.Graphics.CreateTexture2D("Resources/Player.png");
+
+		// プレイヤーのインスタンスに画像の中心位置を設定する。
+		CenterPosition = new ace.Vector2DF(Texture.Size.X / 2.0f, Texture.Size.Y / 2.0f);
+
+		// プレイヤーのインスタンスの位置を設定する。
+		Position = new ace.Vector2DF(320, 240);
+	}

	protected override void OnUpdate()
	{
		// もし、上ボタンが押されていたら、位置に(0,-1)を足す。
		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Up) == ace.KeyState.Hold)
		{
			Position = Position + new ace.Vector2DF(0, -1);
		}
	
		// もし、下ボタンが押されていたら、位置に(0,+1)を足す。
		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Down) == ace.KeyState.Hold)
		{
			Position = Position + new ace.Vector2DF(0, +1);
		}
	
		// もし、左ボタンが押されていたら、位置に(-1,0)を足す。
		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Left) == ace.KeyState.Hold)
		{
			Position = Position + new ace.Vector2DF(-1, 0);
		}
	
		// もし、左ボタンが押されていたら、位置に(+1,0)を足す。
		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Right) == ace.KeyState.Hold)
		{
			Position = Position + new ace.Vector2DF(+1, 0);
		}
	
		// もし、Zキーを押したら{}内の処理を行う。
		if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Z) == ace.KeyState.Push)
		{
			// 弾のインスタンスを生成する。
-			Bullet bullet = new Bullet();
+			Bullet bullet = new Bullet(Position + new ace.Vector2DF(0, -30));
		
-			// 画像を読み込み、弾のインスタンスに画像を設定する。
-			bullet.Texture = ace.Engine.Graphics.CreateTexture2D("Resources/PlayerBullet.png");
-			
-			// 弾のインスタンスに画像の中心位置を設定する。
-			bullet.CenterPosition = new ace.Vector2DF(bullet.Texture.Size.X / 2.0f, bullet.Texture.Size.Y / 2.0f);
		
			// 弾のインスタンスをエンジンに追加する。
			ace.Engine.AddObject2D(bullet);

-			// 弾のインスタンスに位置を設定する。
-			bullet.Position = Position + new ace.Vector2DF(0, -30);
		}
		
		// プレイヤーの位置を取得する。
		ace.Vector2DF position = Position;
	
		// プレイヤーの位置を、(テクスチャの大きさ/2)～(ウインドウの大きさ-テクスチャの大きさ/2)の範囲に制限する。
		position.X = ace.MathHelper.Clamp(position.X, ace.Engine.WindowSize.X - Texture.Size.X / 2.0f, Texture.Size.X / 2.0f);
		position.Y = ace.MathHelper.Clamp(position.Y, ace.Engine.WindowSize.Y - Texture.Size.Y / 2.0f, Texture.Size.Y / 2.0f);
	
		// プレイヤーの位置を設定する。
		Position = position;
		
	}
}

class Program
{
	[STAThread]
	static void Main(string[] args)
	{
		// Altseedを初期化する。
		ace.Engine.Initialize("STG", 640, 480, new ace.EngineOption());

		// プレイヤーのインスタンスを生成する。
		Player player = new Player();
		
-		// 画像を読み込み、プレイヤーのインスタンスに画像を設定する。
-		player.Texture = ace.Engine.Graphics.CreateTexture2D("Resources/Player.png");
-
-		// プレイヤーのインスタンスに画像の中心位置を設定する。
-		player.CenterPosition = new ace.Vector2DF(player.Texture.Size.X / 2.0f, player.Texture.Size.Y / 2.0f);
-
		// エンジンにプレイヤーのインスタンスを追加する。
		ace.Engine.AddObject2D(player);

-		// プレイヤーのインスタンスの位置を変更する。
-		player.Position = new ace.Vector2DF(320, 240);

		// Altseedのウインドウが閉じられていないか確認する。
		while (ace.Engine.DoEvents())
		{
			// もし、Escキーが押されていたらwhileループを抜ける。
			if (ace.Engine.Keyboard.GetKeyState(ace.Keys.Escape) == ace.KeyState.Push)
			{
				break;
			}

			// Altseedを更新する。
			ace.Engine.Update();
		}

		// Altseedの終了処理をする。
		ace.Engine.Terminate();
	}
}

```

コンストラクタはインスタンスが生成された時に実行されるメソッドです。そこで画像を読み込むようにします。
また、コンストラクタには引数を設定できます。
弾クラスでは、引数に座標を設定できるようにしており、初期位置がほぼ引数に指定された位置になるようにしています。

### 画面外に出た弾が消えるようにする

最後に、画面外に出た弾が消えるようにします。

弾が消えるソースコードを弾クラスのOnUpdateに追加します。

```diff
class Bullet : ace.TextureObject2D
{
	public Bullet(ace.Vector2DF position)
	{
		// 画像を読み込み、弾のインスタンスに画像を設定する。
		Texture = ace.Engine.Graphics.CreateTexture2D("Resources/PlayerBullet.png");
	
		// 弾のインスタンスに画像の中心位置を設定する。
		CenterPosition = new ace.Vector2DF(Texture.Size.X / 2.0f, Texture.Size.Y / 2.0f);

		// 弾のインスタンスの位置を設定する。
		Position = position;
	}

	protected override void OnUpdate()
	{
		Position = Position + new ace.Vector2DF(0, -2);

+		// 弾が画面外に出たら
+		if(Position.Y < -Texture.Size.Y)
+		{
+			// 削除する。
+			Vanish();
+		}
	}
}

```

弾が画面外にでたら、``` Vanish ``` メソッドを実行します。このメソッドを実行すると、インスタンスが削除されレイヤーから取り除かれます。

これで画面外の弾が消えない問題は解決されました。

すべての変更を適用した結果をダウンロードできるようにしておきます。参考にしてください。

[プロジェクト(Windows)](Projects/STG05.zip?raw=true)

[プロジェクト(Mac)](Projects/Mac/STG05.zip?raw=true)

### まとめ

本章では、ソースコードを整理しました。このように機能毎にクラスを分けることで、ソースコードが読みやすくなります。

