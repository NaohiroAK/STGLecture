## 09. 当たり判定を実装してみよう

### 概要

前回までの内容で、複雑な動きをする敵がいくつか増えました。
しかし、依然として「自機が敵の弾に当たっても」「敵が自機の弾に当たっても」何も起こらず、これではどうもゲームらしくないですね。

そこで今回は、シューティングゲームにおいて最も重要な「当たり判定」の書き方を解説していきたいと思います。

### 「当たり判定」とは

「当たり判定」とは読んで字の如く、オブジェクト同士が当たっているかどうか判定するものです。当たり判定の実装方法には色々な手法が考えられますが、今回は簡単のために「円同士の当たり判定をピクセル単位で取る」という方法を扱います。

例えば下のような２つの円のオブジェクトを考え、２つの円の中心座標を考えてみましょう。２つの円の半径をa, bとおき、２つの円のx座標の差をd、y座標の差をeとおくと、中学校で習うような「三平方の定理」よりd^2+e^2<(a+b)^2ならば２つの円は「ぶつかっている」ということになりますね。

<図>



### 下準備をしよう

さて、今まで書いたコードについては、当たり判定を導入する前にいくつかの下準備をする必要があります。

#### 当たり判定を保証するインターフェース

まず、当たり判定を持つクラスを決めましょう。今回は、「プレイヤーと敵の弾」、「敵と自機の弾」が衝突してほしいので、 ```Player``` 、 ```Bullet``` 、 ```Enemy``` 、 ```EnemyBullet```　のそれぞれが当たり判定を持つクラスになるはずです。

そこで、C#が持つ[インターフェース](http://ufcpp.net/study/csharp/oo_interface.html)を用いて、クラスを拡張することにします。インターフェースはクラスの規約を決めるもので

「 ```Player``` 、 ```Bullet``` 、 ```Enemy``` 、 ```EnemyBullet```　のそれぞれが当たり判定を持つクラス」

であることを保証するのが、今回の「当たり判定をするインターフェース」の役割です。

では、当たり判定を持つクラスが実装すべきものを決めましょう。

* 位置座標
* 半径
* 相手と衝突したかどうか
* 相手と衝突したときの処理

この4つを実装するように、インターフェースで規約を決めましょう。
プロジェクトに新規追加でcsファイルを追加し、インターフェース ```ICollidable``` のコードを以下のように書きましょう。

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace STG
{
    public interface ICollidable
    {
    	// interface内に記述できるのは抽象プロパティ・メソッドのみで、その実装は行わない。
    	// この中では、プロパティ・メソッドは public abstract を省略して記述される。

        // Position を取得することができる
        ace.Vector2DF Position{get;}

        // Radius(当たり判定の半径) を取得することができる
        float Radius{get;}

        // 衝突しているかどうかを判定するメソッドを実装する
        bool IsCollide(ICollidable obj);

        // 衝突時の処理を行うメソッドを実装する
        void OnCollide(ICollidable obj);
    }
}
```

インターフェースで記述できるのは、あくまで抽象プロパティ・抽象メソッドであり、具体的な値を定めるなどの実装は行わないことに気を付けてください。これを実装するのは **```IColliable```　インターフェースを持つクラスの義務**です。

* 位置座標は ```Position``` 
* 半径は ```Radius```
* 当たり判定は ```IsCollide```
* 当たった時の処理は ```OnCollide``` 

としました。このインターフェースをクラスに規則として加え、そのクラスでこれらの規則を改めて定義する必要があります。

では、例として ```ICollidable``` インターフェースを ```Enemy``` クラスに実装してみましょう。

```Enemy.cs``` ファイルを以下のように編集します。

```diff
-    public class Enemy : ace.TextureObject2D
+    public abstract class Enemy : ace.TextureObject2D, ICollidable
    {
        //毎フレーム1増加し続けるカウンタ変数（継承先のクラスで使いまわすため、protectedに設定する。）
        protected int count;

        //プレイヤーへの参照（継承先のクラスで使いまわすため、protectedに設定する。）
        protected Player player;

+        // 当たり判定の半径、値の取得(get)・代入(set)ができるように宣言
+        public float Radius {get; set;}

        //コンストラクタ(敵の初期位置を引数として受け取る。)
        public Enemy(ace.Vector2DF pos, Player player)
            : base()
        {
            // 敵のインスタンスの位置を設定する。
            Position = pos;

            //　画像を読み込み、敵のインスタンスに画像を設定する。
            Texture = ace.Engine.Graphics.CreateTexture2D("Resources/Enemy.png");

            // 敵のインスタンスに画像の中心位置を設定する。
            CenterPosition = new ace.Vector2DF(Texture.Size.X / 2.0f, Texture.Size.Y / 2.0f);

+            // 画像の半分の大きさを Radius とする
+            Radius = Texture.Size.X / 2.0f;

            // カウンタ変数を0に初期化する。
            count = 0;

            // Playerクラスへの参照を保持する。
            this.player = player;
        }

+        public virtual bool IsCollide(ICollidable obj){
+            // Enemy の当たり判定
+        }

+        public virtual void OnCollide(ICollidable obj){
+            // Enemy の衝突時の処理
+        }
        ...(省略)...

    }
```

では、上記の変更点について解説します。

**※以下の解説は、初心者には若干重い可能性があります。解説を読んでモチベーションが下がるくらいなら変更点のみをコードに反映して、解説を読み飛ばすことをオススメします。**
(なんでこうする必要があったのか、気になったら読んでみてください。)

##### abstract とは
まず、突然現れた ```public abstract class``` についてですが、クラスに ```abstract``` 修飾子をつけることによって、このクラスが[抽象クラス](http://ufcpp.net/studY/csharp/oo_abstract.html)であることが示されます。

抽象クラスの特徴として、**直接インスタンス化してはいけない**という制限があります。

ゲームとして、敵キャラの要件は満たしているけれども、移動など細かいところは（それが雑魚敵でも）工夫が必要になる場合が多いです。そのため、8章では敵をクラス分けし、 ```Enemy``` クラスを全く動かない敵キャラとして、様々な動きをする「敵キャラのクラス」を別々に作りました。

この場合、 ```Enemy``` クラスのインスタンスそのものをゲームに登場させる必要はないはずです。ですから、ここではこの ```Enemy``` クラスを ```abstract class``` (抽象クラス) として取り扱います。これは ```EnemyBullet``` クラスにも同じことが言えますし、もし ```Bullet```　クラス(自機の弾のクラス) に種類のバリエーションが欲しいと思った場合には、 ```Bullet``` クラスを抽象クラスにする必要があるでしょう。

##### クラスにインターフェースを実装する

クラスにインターフェースを実装するためには、継承と同じような方法を用います。

	class クラス名 : インターフェース名
	{
	  クラスの定義
	}

クラスが継承できる基底クラス（親クラス）はC\#では1つだけですが、インターフェースは複数実装することができます。なぜなら、インターフェースはあくまで規約であり実装を伴わないので、継承元がコンフリクトすることがないからです。

基底クラスに加えて、インターフェースを実装する場合には、

	class クラス名 : 基底クラス名, インターフェース名

というように、カンマで区切ることでインターフェースを実装することができます。これは、複数のインターフェースを実装する場合も同様です。

今回の場合は

	class Enemy : ace.TextureObject2D, ICollidable

と読み替えることができます。

##### インターフェースに沿って実装をする

実装すべきものは4点ありました。

* 位置座標は ```Position``` 
* 半径は ```Radius```
* 当たり判定は ```IsCollide```
* 当たった時の処理は ```OnCollide``` 

このうち ```Position``` は、 ```ace.TextureObject2D``` クラスを継承した際、既に実装されています。
これについては、新たに実装する必要性はありません。

半径として ```Radius``` を実装する必要があります。インターフェースではフィールド（変数）を宣言できないので、[プロパティ](http://ufcpp.net/study/csharp/oo_property.html)として宣言する必要があった ```Radius``` ですが、ここでは ```get``` (値の取得)、 ```set``` (値の代入) ができるように以下のように宣言しています。

	public float Radius {get; set;}

単純にフィールド(変数)として宣言できないことに注意しましょう。

次に、```IsCollide``` と ```OnCollide``` です。

どちらのメソッドにも ```virtual``` という修飾子があります。これは、実装はしているが、子クラスがこのメソッドを ```override``` (上書き)することを認める記述です。基本的な動作は決まっているが、子クラスでもメソッドを工夫する可能性がある場合に使えるキーワードです。

メソッドの内部は後ほど実装することにしましょう。

### 実装してみよう

では、実際に当たり判定のコードを実装してみましょう。実装は、以下のようになります。

### コラム：さらに踏み込んだ当たり判定を作るには

ここまでの方法で、「１つのフレーム内で、キャラクターと弾が当たっているかどうか」という当たり判定を取得することが出来ました。今回は自機の動作も敵の動作もゆっくりしているので、大方見た目通りの当たり判定が取れるようになっているかと思います。

ここで、次のような場合を考えてみましょう。

<図>

困ったことになりました。この２フレームの「間」では２つの物体は「当たっている」はずなのですが、両方のフレームでは計算上「当たっていない」ことになっているため、見かけ上「すり抜け」が起きてしまいます。
このような「すり抜け」を回避するためには、２つの物体の現在地と移動ベクトルを利用し、下図のように２つの物体の進路に交点があるかどうかを計算する必要があります。

<図>

具体的な計算方法については本章では長くなるため省略しますが、踏み込んだ当たり判定の方法としてこのような方法もあるということは覚えておくとよいでしょう。