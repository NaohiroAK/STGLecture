## 08. 複雑な敵の動き

### 概要

前回までの内容で、敵の弾と作って敵がそれを撃ってくるようにしました。今回は第5回にて紹介した継承を用いて異なる動きをする様々な敵や弾を作りましょう。

### 自機に突進してくる敵

まずは、自機に突進してくる敵を実装してみましょう。具体的には、一定時間かけて自機に突進してくる→一定時間停止する　をくり返すという挙動となります。

ソースファイル```RushingEnemy.cs```を作成し、以下のように書いてください。

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace STG
{
    public class RushingEnemy :Enemy
    {
        //移動の際の速度ベクトル。
        private ace.Vector2DF moveVelocity;

        public RushingEnemy(ace.Vector2DF pos,Player player)
            :base(pos, player)
        {
            //速度ベクトルベクトルを初期化。
            moveVelocity = new ace.Vector2DF();
        }

        protected override void OnUpdate()
        {
            //カウンタ変数を120で割った値を求める。
            int mod = count % 120;

            //mod = 0のとき
            if (mod == 0)
            {
                //その時点での自機に向かう速度ベクトルを求める。
                moveVelocity = (playerRef.Position - Position).Normal * 5.0f;
            }
            else if (mod <= 60) // 1 <= mod <= 60 のとき
            {
                //速度ベクトルをPositionに加算して移動する。
                Position += moveVelocity;
            }

            ++count;
        }
    }
}

```

```FollowingEnemy```は```Enemy```を基底クラスとして継承することで作成します。継承することによって、基底クラスの変数やメソッドを使いまわすことが可能です。このクラスでは基底クラスで宣言済みのPlayerクラスへの参照を示す```playerRef```並びに毎フレームごとに値が増えていくカウンタ変数```count```を使いまわします。

具体的には、カウンタ変数の値を120で割った余りを求め、その値に応じて以下の様な動きをさせます。

* 0 : 速度ベクトル```moveVector```をその時点での自機の位置に向かって毎フレーム5.0移動するように設定する。
* 1 ~ 60 : ```Position```変数に毎フレーム```moveVector```を加算することで移動する。
* 61 ~ 119 : 停止する。（何もしない。）

このソースコードをビルドすると、以下の様なエラーが出て失敗してしまいました。

```
1>(省略)\STG08\STG\FollowingEnemy.cs(24,23,24,28): error CS0122: 'STG.Enemy.count' is inaccessible due to its protection level
1>(省略)\STG08\STG\FollowingEnemy.cs(30,33,30,42): error CS0122: 'STG.Enemy.playerRef' is inaccessible due to its protection level
1>(省略)\STG08\STG\FollowingEnemy.cs(38,15,38,20): error CS0122: 'STG.Enemy.count' is inaccessible due to its protection level```

以上のエラーを日本語でまとめると「STG.Enemy.countとSTG.Enemy.playerRefはそれらの保護レベル(protection Level)によってアクセス出来ない。」という意味になります。、つまり継承クラスからこの二変数にはアクセス出来ないということです。
これを修正すべく、```Enemy```クラスの記述内の変数```count```と```playerRef```の宣言を見てみましょう。これらは以下のように書かれています。

```cs
//自機への参照を持つ変数。
private Player playerRef;

//1フレームごとに1増加していくカウンタ変数。
private int count;
```

それぞれの冒頭に```private```と書かれていますが、これを書くことによって、この変数はこの宣言を書いたクラス内からのみ参照可能という意味になります。宣言を書いたクラスに含め、継承先のクラスのクラスからも参照できるようにするには、以下のように```private```を```protected```に書き換えます。

```cs
//自機への参照を持つ変数。
protected Player playerRef;

//1フレームごとに1増加していくカウンタ変数。
protected int count;
```

これによってビルドが通りましたね。それでは、```Program.cs```の```Main```関数を変更して、この敵をゲームに登場させましょう。

```cs
～省略～

// レイヤーに自機オブジェクトを追加する。
layer.AddObject(player);

//======== 変更されるソースコード ========//

//突進する敵オブジェクトを生成する。
RushingEnemy followingEnemy = new RushingEnemy(new ace.Vector2DF(320, 100), player);
//レイヤーに突進する敵オブジェクトを追加する。
layer.AddObject(followingEnemy);

//======== ここまで ========//

// シーンを切り替える。
ace.Engine.ChangeScene(scene);

～省略～

実行すると、敵が自機めがけて突進→停止を一定の間隔でくり返すことが確認できます。
```

### 決まった地点の周りをグルグル動く敵

新たな動きをする敵とその弾を実装するには第6回と第7回で作成した```Enemy```クラスと```EnemyBullet```クラスを継承していきます。

```C#
megapiyo
```

### 渦状に弾を拡散する敵

まずは、```EnemyBullet```を継承して、渦上に弾を拡散する敵を実装してみましょう。

```C#
megapiyo
```

### 分裂する弾

続いて、```EnemyBullet```を継承して、飛んでいる途中に複数の弾に分裂する弾を作ってみましょう。

```C#
hogepiyo
```

### まとめ

本章では、いろんな動きの敵や敵の弾を作りました。次回は、自機や敵が衝突したか否かを調べる当たり判定を実装しましょう。

