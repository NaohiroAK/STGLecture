## 08. 複雑な敵の動き

### 概要

前回までの内容で、敵の弾と作って敵がそれを撃ってくるようにしました。今回は第5回にて紹介した継承を用いて異なる動きをする様々な敵や弾を作りましょう。

### 自機に突進してくる敵

まずは、自機に突進してくる敵を実装してみましょう。具体的には、一定時間かけて自機に突進してくる→一定時間停止する　をくり返すという挙動となります。

ソースファイル```RushingEnemy.cs```を作成し、以下のように書いてください。

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace STG
{
    public class RushingEnemy :Enemy
    {
        //移動の際の速度ベクトル。
        private ace.Vector2DF moveVelocity;

        public RushingEnemy(ace.Vector2DF pos,Player player)
            :base(pos, player)
        {
            //速度ベクトルベクトルを初期化。
            moveVelocity = new ace.Vector2DF();
        }

        protected override void OnUpdate()
        {
            //カウンタ変数を120で割った値を求める。
            int mod = count % 120;

            //mod = 0のとき
            if (mod == 0)
            {
                //その時点での自機に向かう速度ベクトルを求める。
                moveVelocity = (playerRef.Position - Position).Normal * 5.0f;
            }
            else if (mod <= 60) // 1 <= mod <= 60 のとき
            {
                //速度ベクトルをPositionに加算して移動する。
                Position += moveVelocity;
            }

            ++count;
        }
    }
}

```

この```RushingEnemy```は```Enemy```を基底クラスとして継承することで作成します。継承することによって、基底クラスの変数やメソッドを使いまわすことが可能です。このクラスでは基底クラスで宣言済みのPlayerクラスへの参照を示す```playerRef```並びに毎フレームごとに値が増えていくカウンタ変数```count```を使いまわします。

具体的には、カウンタ変数の値を120で割った余りを求め、その値に応じて以下の様な動きをさせます。

* 0 : 速度ベクトル```moveVector```をその時点での自機の位置に向かって毎フレーム5.0移動するように設定する。
* 1 ~ 60 : ```Position```変数に毎フレーム```moveVector```を加算することで移動する。
* 61 ~ 119 : 停止する。（何もしない。）

このソースコードをビルドすると、以下の様なエラーが出て失敗してしまいました。

```
1>(省略)\STG08\STG\RushingEnemy.cs(24,23,24,28): error CS0122: 'STG.Enemy.count' is inaccessible due to its protection level
1>(省略)\STG08\STG\RushingEnemy.cs(30,33,30,42): error CS0122: 'STG.Enemy.playerRef' is inaccessible due to its protection level
1>(省略)\STG08\STG\RushingEnemy.cs(38,15,38,20): error CS0122: 'STG.Enemy.count' is inaccessible due to its protection level```

以上のエラーを日本語でまとめると「STG.Enemy.countとSTG.Enemy.playerRefはそれらの保護レベル(protection Level)によってアクセス出来ない。」という意味になります。、つまり継承クラスからこの二変数にはアクセス出来ないということです。
これを修正すべく、```Enemy```クラスの記述内の変数```count```と```playerRef```の宣言を見てみましょう。これらは以下のように書かれています。

```cs
//自機への参照を持つ変数。
private Player playerRef;

//1フレームごとに1増加していくカウンタ変数。
private int count;
```

それぞれの冒頭に```private```と書かれていますが、これを書くことによって、この変数はこの宣言を書いたクラス内からのみ参照可能という意味になります。宣言を書いたクラスに含め、継承先のクラスのクラスからも参照できるようにするには、以下のように```private```を```protected```に書き換えます。

```cs
//自機への参照を持つ変数。
protected Player playerRef;

//1フレームごとに1増加していくカウンタ変数。
protected int count;
```

これによってビルドが通りましたね。それでは、```Program.cs```の```Main```関数を変更して、この敵をゲームに登場させましょう。

```cs
～省略～

// レイヤーに自機オブジェクトを追加する。
layer.AddObject(player);

//======== 変更されるソースコード ========//

//突進する敵オブジェクトを生成する。
RushingEnemy rushingEnemy = new RushingEnemy(new ace.Vector2DF(320, 100), player);
//レイヤーに突進する敵オブジェクトを追加する。
layer.AddObject(rushingEnemy);

//======== ここまで ========//

// シーンを切り替える。
ace.Engine.ChangeScene(scene);

～省略～
```

実行すると、以下に示すように敵が自機めがけて突進→停止を一定の間隔でくり返すことが確認できます。

### 反復して移動する敵(三角関数使用版)

第06回で左右に反復して移動する敵を作りましたが、方向転換の時に減速もなしにいきなり逆方向に行くため、その瞬間がどうも不細工に見えてしまいます。そこで、方向転換が近い時に減速し、逆方向に行った瞬間から加速し始めるような反復して動く敵を作ってみましょう。

ソースファイル```GentlyMovingEnemy.cs```を作成し、以下のように書いてください。

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace STG
{
    public class GentlyMovingEnemy : Enemy
    {
        //移動の際の基準となる位置。
        private ace.Vector2DF basePosition;

        public GentlyMovingEnemy(ace.Vector2DF pos, Player player)
            : base(pos, player)
        {
            //移動の際の基準となる位置を初期化
            basePosition = pos;
        }

        protected override void OnUpdate()
        {
            //basePositionに(X,Y) = ( sin(count*2) , 0 )のベクトルをX,Y成分それぞれ50.0倍した結果を新たな位置とする。
            Position = basePosition + 50.0f * new ace.Vector2DF((float)Math.Sin((count * 2) * Math.PI / 180.0f), 0);

            ++count;
        }
    }
}
```

この動きを実現するにあたって、三角関数のsinを使用するのですが、こちらはC#の標準ライブラリに含まれている数学関数のSinを使用します。これは名前空間```System```内に宣言された静的クラス```Math```内に書かれています。
[MSDNに記されているSin関数の記事](https://msdn.microsoft.com/ja-jp/library/system.math.sin(v=vs.110).aspx)を見てみましょう。どうやらラジアン値を引数```(a)```として与えると、```sin(a)```が返ってくる関数のようです。

```count*2```は度数値なのでラジアン値に変換する必要があります。変換するには度数値をdとして以下のようにします。

```
 r = d * π / 180
```

πは```Math.PI```に定義されているのでそれを使用します。上記の変換式で変換した値をMath.Sinに与えるとその計算した値が返り値として返ってくるのですが、その返り値の型はdouble型となっております。この値をace.Vector2DFのコンストラクタで渡すのですが、その引数はいずれもfloat型となっています。C#においてdouble型からfloat型への暗黙的な型変換は許されていないため、その変換を明示する必要があります。
そこで、以下に示すようにしてSinの返り値の値をfloat型に変換します。

```
(float)Math.Sin((count * 2) * Math.PI / 180.0f)
```

これで```basePosition```に加算するベクトルが準備出来ました。三角関数sinの値の値域は-1～+1なので、その値域が-50～+50になるよう```50.0f```を乗算します。この最終的な値を```basePosition```に加算した結果を敵の位置とすることで完成です。

それでは、この反復して移動する敵の三角関数版も以下のように```Program.cs```の```Main```関数を一部変更することでゲーム上に登場させましょう。

```cs
～省略～

// レイヤーに自機オブジェクトを追加する。
layer.AddObject(player);

//突進する敵オブジェクトを生成する。
RushingEnemy rushingEnemy = new RushingEnemy(new ace.Vector2DF(320, 100), player);
//レイヤーに突進する敵オブジェクトを追加する。
layer.AddObject(rushingEnemy);

//======== 追加するソースコード ========//

//突進する敵オブジェクトを生成する。
GentlyMovingEnemy gentlyMovingEnemy = new GentlyMovingEnemy(new ace.Vector2DF(320, 100), player);
//レイヤーに突進する敵オブジェクトを追加する。
layer.AddObject(gentlyMovingEnemy);

//======== ここまで ========//

// シーンを切り替える。
ace.Engine.ChangeScene(scene);

～省略～
```

実行結果を見ると、以下に示すように突進する敵と新・反復して動く敵が表示されているのが分かります。

### 決まった地点の周りをグルグル動く敵

新たな動きをする敵とその弾を実装するには第6回と第7回で作成した```Enemy```クラスと```EnemyBullet```クラスを継承していきます。

```C#
megapiyo
```

### 渦状に弾を拡散する敵

まずは、```EnemyBullet```を継承して、渦上に弾を拡散する敵を実装してみましょう。

```C#
megapiyo
```

### 分裂する弾

続いて、```EnemyBullet```を継承して、飛んでいる途中に複数の弾に分裂する弾を作ってみましょう。

```C#
hogepiyo
```

### まとめ

本章では、いろんな動きの敵や敵の弾を作りました。次回は、自機や敵が衝突したか否かを調べる当たり判定を実装しましょう。

